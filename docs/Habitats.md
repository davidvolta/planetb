# Habitats Implementation

## Zustand State Implementation Approach

### 1. Define Habitat Types

```typescript
// Habitat state enum
export enum HabitatState {
  POTENTIAL = 'potential',
  SHELTER = 'shelter'
}

// Shelter types based on terrain
export enum ShelterType {
  TIDEPOOL = 'tidepool',  // beach
  NEST = 'nest',         // mountain
  DEN = 'den',           // grass  
  CAVE = 'cave',         // underwater
  REEF = 'reef'          // water
}

// Habitat interface
interface Habitat {
  id: string;
  position: Coordinate;
  state: HabitatState;
  shelterType: ShelterType | null;
  ownerId: number | null;  // Player ID that owns this habitat
  resources: number;      // Resources generated by the habitat
}
```

### 2. Update GameState Interface

```typescript
export interface GameState {
  // Existing properties
  turn: number;
  players: Player[];
  currentPlayerId: number;
  board: Board | null;
  animals: Animal[];
  
  // Add habitats array
  habitats: Habitat[];
  
  // Existing methods
  nextTurn: () => void;
  // ...existing methods...
  
  // Add habitat-related methods
  addPotentialHabitat: (x: number, y: number) => void;
  improveHabitat: (habitatId: string) => void;
  getHabitatAt: (x: number, y: number) => Habitat | undefined;
}
```

### 3. Zustand Store Implementation

```typescript
export const useGameStore = create<GameState>((set, get) => ({
  // Existing state
  turn: 1,
  players: [],
  currentPlayerId: 0,
  board: null,
  animals: [],
  habitats: [],

  // Existing actions
  // ...

  // New habitat-related actions
  addPotentialHabitat: (x: number, y: number) => 
    set((state) => {
      const newHabitat: Habitat = {
        id: `habitat-${state.habitats.length}`,
        position: { x, y },
        state: HabitatState.POTENTIAL,
        shelterType: null,
        ownerId: null,
        resources: 0
      };
      return { habitats: [...state.habitats, newHabitat] };
    }),

  improveHabitat: (habitatId: string) =>
    set((state) => {
      const board = state.board;
      if (!board) return { habitats: state.habitats };

      const updatedHabitats = state.habitats.map(habitat => {
        if (habitat.id !== habitatId || habitat.state !== HabitatState.POTENTIAL) {
          return habitat;
        }
        
        // Get tile at the habitat position
        const tile = board.tiles[habitat.position.y]?.[habitat.position.x];
        if (!tile) return habitat;
        
        // Determine shelter type based on terrain
        let shelterType: ShelterType;
        switch (tile.terrain) {
          case TerrainType.BEACH:
            shelterType = ShelterType.TIDEPOOL;
            break;
          case TerrainType.MOUNTAIN:
            shelterType = ShelterType.NEST;
            break;
          case TerrainType.GRASS:
            shelterType = ShelterType.DEN;
            break;
          case TerrainType.UNDERWATER:
            shelterType = ShelterType.CAVE;
            break;
          case TerrainType.WATER:
            shelterType = ShelterType.REEF;
            break;
          default:
            shelterType = ShelterType.DEN; // Fallback
        }
        
        return {
          ...habitat,
          state: HabitatState.SHELTER,
          shelterType,
          ownerId: state.currentPlayerId,
          resources: 10 // Initial resources, could vary by shelter type
        };
      });
      
      return { habitats: updatedHabitats };
    }),

  getHabitatAt: (x, y) => {
    return get().habitats.find(
      habitat => habitat.position.x === x && habitat.position.y === y
    );
  },
}));
```

### 4. Additional Considerations

1. **Resource Generation**: Add a method to update habitat resources during turn changes:
   ```typescript
   nextTurn: () => set((state) => {
     // Update habitat resources
     const updatedHabitats = state.habitats.map(habitat => {
       if (habitat.state === HabitatState.SHELTER) {
         return {
           ...habitat,
           resources: habitat.resources + getResourceRate(habitat.shelterType)
         };
       }
       return habitat;
     });
     
     return { 
       turn: state.turn + 1,
       habitats: updatedHabitats
     };
   }),
   ```

2. **Generating Potential Habitats**: You might want a method to randomly generate potential habitats on game start:
   ```typescript
   generatePotentialHabitats: (count: number) => set((state) => {
     if (!state.board) return { habitats: [] };
     
     const newHabitats: Habitat[] = [];
     const boardPositions = new Set();
     
     // Try to place habitats randomly
     for (let i = 0; i < count * 2 && newHabitats.length < count; i++) {
       const x = Math.floor(Math.random() * state.board.width);
       const y = Math.floor(Math.random() * state.board.height);
       const posKey = `${x},${y}`;
       
       // Skip if position already has a habitat
       if (boardPositions.has(posKey)) continue;
       
       // Avoid water for potential habitats (optional)
       const terrain = state.board.tiles[y]?.[x]?.terrain;
       if (terrain === TerrainType.WATER || terrain === TerrainType.UNDERWATER) continue;
       
       boardPositions.add(posKey);
       newHabitats.push({
         id: `habitat-${state.habitats.length + newHabitats.length}`,
         position: { x, y },
         state: HabitatState.POTENTIAL,
         shelterType: null,
         ownerId: null,
         resources: 0
       });
     }
     
     return { habitats: [...state.habitats, ...newHabitats] };
   }),
   ```
