import { create } from "zustand";
import { generateIslandTerrain } from "../utils/terrainGenerator";

// Coordinate system for tiles
interface Coordinate {
  x: number;
  y: number;
}

// Terrain types
export enum TerrainType {
  WATER = 'water',
  GRASS = 'grass',
  BEACH = 'beach',
  MOUNTAIN = 'mountain',
  UNDERWATER = 'underwater',
}

// Only island map generation is available now
export enum MapGenerationType {
  ISLAND = 'island'
}

// Habitat state enum
export enum HabitatState {
  POTENTIAL = 'potential',
  SHELTER = 'shelter'
}

// Shelter types based on terrain
export enum ShelterType {
  TIDEPOOL = 'tidepool',  // beach
  NEST = 'nest',         // mountain
  DEN = 'den',           // grass  
  CAVE = 'cave',         // underwater
  REEF = 'reef'          // water
}

// Habitat structure
interface Habitat {
  id: string;
  position: Coordinate;
  state: HabitatState;
  shelterType: ShelterType | null;
  ownerId: number | null;  // Player ID that owns this habitat
  resources: number;      // Resources generated by the habitat
}

// Tile structure
interface Tile {
  coordinate: Coordinate;
  terrain: TerrainType;
  explored: boolean;
  visible: boolean;
}

// Board structure
interface Board {
  width: number;
  height: number;
  tiles: Tile[][];
}

interface Player {
  id: number;
  name: string;
  color: string;
  isActive: boolean;
}

// Animal states
export enum AnimalState {
  DORMANT = 'dormant',
  ACTIVE = 'active',
}

// Base animal structure
interface Animal {
  id: string;
  type: string;
  state: AnimalState;
  position: Coordinate;
}



// Game state interface
export interface GameState {
  turn: number;
  players: Player[];
  currentPlayerId: number;
  board: Board | null;
  animals: Animal[];
  habitats: Habitat[];
  isInitialized: boolean;  // Flag to track if the game has been initialized
  
  nextTurn: () => void;
  addPlayer: (name: string, color: string) => void;
  setActivePlayer: (playerId: number) => void;
  initializeBoard: (width: number, height: number, mapType?: MapGenerationType) => void;
  getTile: (x: number, y: number) => Tile | undefined;
  
  addAnimal: (x: number, y: number, type?: string) => void;
  evolveAnimal: (id: string) => void;
  
  // Habitat-related methods
  addPotentialHabitat: (x: number, y: number) => void;
  improveHabitat: (habitatId: string) => void;
  getHabitatAt: (x: number, y: number) => Habitat | undefined;
}

export const useGameStore = create<GameState>((set, get) => ({
  turn: 1,
  players: [],
  currentPlayerId: 0,
  board: null,
  animals: [],
  habitats: [],
  isInitialized: false,

  nextTurn: () => set((state) => ({ turn: state.turn + 1 })),

  addPlayer: (name: string, color: string) => 
    set((state) => {
      const newPlayer: Player = {
        id: state.players.length,
        name,
        color,
        isActive: state.players.length === 0, // First player starts active
      };
      return { players: [...state.players, newPlayer] };
    }),

  setActivePlayer: (playerId: number) =>
    set((state) => {
      const updatedPlayers = state.players.map(player => ({
        ...player,
        isActive: player.id === playerId
      }));
      return { players: updatedPlayers, currentPlayerId: playerId };
    }),

  initializeBoard: (width, height, mapType = MapGenerationType.ISLAND) =>
    set((state) => {
      const terrainData = generateIslandTerrain(width, height);
      const tiles: Tile[][] = [];

      for (let y = 0; y < height; y++) {
        const row: Tile[] = [];
        for (let x = 0; x < width; x++) {
          row.push({
            coordinate: { x, y },
            terrain: terrainData[y][x],
            explored: false,
            visible: true,
          });
        }
        tiles.push(row);
      }

      // Generate initial habitats if this is first initialization
      let habitats: Habitat[] = [];
      if (!state.isInitialized) {
        // Create a map to track which terrain types we've placed habitats on
        const terrainTypesWithHabitats = new Set<TerrainType>();
        
        // Create an array of all terrain types to ensure we place exactly one habitat per type
        const allTerrainTypes = Object.values(TerrainType);
        
        // For each terrain type, find a suitable location and place a habitat
        allTerrainTypes.forEach(terrainType => {
          // Collect all tiles of this terrain type
          const tilesOfType: {x: number, y: number}[] = [];
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              if (terrainData[y][x] === terrainType) {
                tilesOfType.push({ x, y });
              }
            }
          }
          
          // If we have tiles of this type, place a habitat on one randomly
          if (tilesOfType.length > 0) {
            const randomIndex = Math.floor(Math.random() * tilesOfType.length);
            const { x, y } = tilesOfType[randomIndex];
            
            const habitatId = terrainTypesWithHabitats.size;
            const newHabitat: Habitat = {
              id: `habitat-${habitatId}`,
              position: { x, y },
              state: HabitatState.POTENTIAL,
              shelterType: null,
              ownerId: null,
              resources: 0,
            };
            
            habitats.push(newHabitat);
            terrainTypesWithHabitats.add(terrainType);
          }
        });
        
        // Verify we've placed exactly one habitat per available terrain type
        console.log(`Initialized ${habitats.length} habitats on ${terrainTypesWithHabitats.size} terrain types`);
      }

      return { 
        board: { width, height, tiles },
        isInitialized: true,
        // Use new habitats if first initialization, otherwise keep existing ones
        habitats: state.isInitialized ? state.habitats : habitats
      };
    }),

  getTile: (x, y) => {
    const board = get().board;
    if (!board) return undefined;
    if (x < 0 || x >= board.width || y < 0 || y >= board.height) return undefined;
    return board.tiles[y][x];
  },

  addAnimal: (x, y, type = "buffalo") =>
    set((state) => {
      const newAnimal: Animal = {
        id: `animal-${state.animals.length}`,
        type: type,
        state: AnimalState.DORMANT,
        position: { x, y },
      };
      return { animals: [...state.animals, newAnimal] };
    }),

  evolveAnimal: (id) =>
    set((state) => {
      const evolvedAnimals = state.animals.map(animal =>
        animal.id === id
          ? { ...animal, state: AnimalState.ACTIVE }
          : animal
      );
      return { animals: evolvedAnimals };
    }),

  addPotentialHabitat: (x: number, y: number) =>
    set((state) => {
      const newHabitat: Habitat = {
        id: `habitat-${state.habitats.length}`,
        position: { x, y },
        state: HabitatState.POTENTIAL,
        shelterType: null,
        ownerId: null,
        resources: 0,
      };
      return { habitats: [...state.habitats, newHabitat] };
    }),

  improveHabitat: (habitatId: string) =>
    set((state) => {
      const board = state.board;
      if (!board) return { habitats: state.habitats };

      const updatedHabitats = state.habitats.map(habitat => {
        if (habitat.id !== habitatId || habitat.state !== HabitatState.POTENTIAL) {
          return habitat;
        }
        
        // Get tile at the habitat position
        const tile = board.tiles[habitat.position.y]?.[habitat.position.x];
        if (!tile) return habitat;
        
        // Determine shelter type based on terrain
        let shelterType: ShelterType;
        switch (tile.terrain) {
          case TerrainType.BEACH:
            shelterType = ShelterType.TIDEPOOL;
            break;
          case TerrainType.MOUNTAIN:
            shelterType = ShelterType.NEST;
            break;
          case TerrainType.GRASS:
            shelterType = ShelterType.DEN;
            break;
          case TerrainType.UNDERWATER:
            shelterType = ShelterType.CAVE;
            break;
          case TerrainType.WATER:
            shelterType = ShelterType.REEF;
            break;
          default:
            shelterType = ShelterType.DEN; // Fallback
        }
        
        return {
          ...habitat,
          state: HabitatState.SHELTER,
          shelterType,
          ownerId: state.currentPlayerId,
          resources: 10 // Initial resources, could vary by shelter type
        };
      });
      
      return { habitats: updatedHabitats };
    }),

  getHabitatAt: (x: number, y: number) => {
    const habitats = get().habitats;
    if (!habitats) return undefined;
    return habitats.find(habitat =>
      habitat.position.x === x && habitat.position.y === y
    );
  },
}));
